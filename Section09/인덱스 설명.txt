[ 인덱스(Index) ]
인덱스는 데이터베이스에서 검색 속도를 향상시키기 위해 사용되는 데이터 구조입니다. 
데이터베이스 테이블의 특정 열(칼럼)에 대해 생성되며, 
이 열에 대한 값과 해당 값이 위치한 테이블의 레코드 위치를 매핑하여 빠른 검색을 가능하게 합니다. 

[ 인덱스의 개념 ]
인덱스: 
데이터베이스에서 검색 성능을 향상시키기 위해 특정 열(칼럼)에 대해 생성된 데이터 구조.

인덱스 키(Index Key): 
인덱스를 구성하는 열(칼럼)의 값.

인덱스 엔트리(Index Entry):
인덱스 키와 해당 키의 위치(테이블의 레코드 주소)를 매핑한 항목.

[ 인덱스를 사용하는 이유 ]
1. 검색 성능 향상: 
인덱스를 사용하면 데이터 검색 시 테이블 전체를 순차적으로 검색하는 것보다 빠르게 원하는 데이터를 찾을 수 있음.

2. 정렬 및 범위 검색 최적화: 
인덱스를 사용하면 정렬된 상태로 데이터에 접근할 수 있어 정렬된 데이터를 반환하거나 범위 검색을 효율적으로 수행할 수 있음.

[ 카디널러티(Cardinality) ]
카디널러티: 인덱스의 유일한 값의 수를 나타내는 개념.

높은 카디널러티(고유한 값이 많음): 
	인덱스를 사용하여 데이터를 필터링할 때 더 효율적인 검색이 가능.

낮은 카디널러티(고유한 값이 적음): 
	인덱스를 사용하여 데이터를 필터링할 때 검색 효율이 떨어질 수 있음.

[ 인덱스의 문제점 ]
1. 저장 공간 추가 사용: 
인덱스를 생성하면 데이터베이스의 저장 공간을 추가로 사용하게 됨.

2. 인덱스 업데이트 오버헤드: 
데이터의 삽입, 수정, 삭제 시 인덱스를 업데이트하는 작업이 필요하므로 이로 인해 오버헤드가 발생할 수 있음.

[ 인덱스를 사용해야 하는 경우 ]
1. 검색(SELECT)이 자주 수행되는 칼럼에 대해.
2. 정렬된 결과가 필요한 경우(ORDER BY).
3. 범위 검색이 필요한 경우(WHERE 조건).

[ 인덱스를 사용하지 말아야 하는 경우 ]
1. 테이블의 레코드 수가 적을 때(인덱스를 사용하면 추가적인 오버헤드만 발생할 수 있음).
2. 자주 변경되는 열(칼럼)에 대해(INSERT, UPDATE, DELETE가 빈번할 때)

[ 인덱스의 장단점 ]
장점:
1. 검색 성능 향상.
2. 정렬 및 범위 검색 최적화.
3. 데이터의 유일성 보장.

단점:
1. 저장 공간 추가 사용.
2. 데이터 변경 시 인덱스 업데이트 오버헤드.

[ 인덱스의 종류 ]
1. 클러스터형 인덱스(Clustered Index): 
테이블의 데이터를 물리적으로 정렬된 상태로 저장하는 인덱스.

2. 보조 인덱스(Secondary Index): 
테이블의 데이터를 정렬하지 않고, 인덱스만 따로 정렬하여 관리하는 인덱스.

[ 자동으로 생성되는 인덱스 ]
1. 클러스터형 인덱스(Clustered Index): 
주 키(PK)를 기반으로 테이블 생성 시 자동으로 생성되는 인덱스.

2. 제약조건으로 자동 생성되는 인덱스:
UNIQUE: 중복을 허용하지 않는 유니크한 값에 대한 인덱스.
PRIMARY KEY: 주 키(PK)에 대한 인덱스.

[ 클러스터형 인덱스의 정렬 확인하기 ]
1. 클러스터형 인덱스는 주 키(PK)를 기반으로 테이블의 데이터를 물리적으로 정렬하여 저장합니다.
2. 오름차순(ASC) 정렬 결과를 확인하려면 해당 인덱스를 사용하여 데이터를 조회하면 됩니다.

--------------------------------------------------------------------------------------------------------------------------
1. primary key로 지정한 열에 클러스터형 인덱스가 생성
2. unique not null로 지정한 열에 클러스터형 인덱스가 생성
3. unique 또는 unique not null로 지정한 열에 보조 인덱스가 생성
4. primary key와 unique not null 이 같이 있으면 primary key로 지정한 열에 우선 클러서트형 인덱스가 생성
5. primary key로 지정한 열을 기준으로 데이터가 오름차순 정렬

[ 제약 조건인 PRIMARY KEY, UNIQUE, NOT NULL에 따라 인덱스가 자동으로 생성되는 규칙 ]

1. PRIMARY KEY로 지정한 열에 클러스터형 인덱스가 생성되는 경우
PRIMARY KEY는 각 행을 유일하게 식별하는 열(또는 열의 조합)을 정의하는 제약 조건입니다.
PRIMARY KEY로 지정한 열에는 데이터베이스 시스템이 자동으로 클러스터형(클러스터링된) 인덱스를 생성합니다.
클러스터형 인덱스는 테이블의 레코드들을 해당 인덱스의 순서로 물리적으로 정렬하여 저장합니다.

2. UNIQUE NOT NULL로 지정한 열에 클러스터형 인덱스가 생성되는 경우
UNIQUE NOT NULL은 해당 열의 값이 중복되지 않고 NULL이 아닌 값을 가지도록 보장하는 제약 조건입니다.
UNIQUE NOT NULL로 지정한 열에도 데이터베이스 시스템이 자동으로 클러스터형 인덱스를 생성합니다.
클러스터형 인덱스는 해당 열의 값에 대해 유일성을 보장하고 빠른 검색을 제공합니다.

3. UNIQUE 또는 UNIQUE NOT NULL로 지정한 열에 보조 인덱스가 생성되는 경우
UNIQUE 또는 UNIQUE NOT NULL 제약 조건이 있는 열에는,
데이터베이스 시스템이 자동으로 보조 인덱스(Secondary Index)를 생성합니다.
보조 인덱스는 해당 열의 값에 대해 유일성을 보장하고 빠른 검색을 지원합니다. 주로 UNIQUE 제약 조건이 지정된 열에 생성됩니다.

4. PRIMARY KEY와 UNIQUE NOT NULL이 같이 있으면 PRIMARY KEY로 지정한 열에 우선 클러스터형 인덱스가 생성되는 경우
PRIMARY KEY와 UNIQUE NOT NULL 제약 조건이 동일한 열에 모두 지정된 경우, PRIMARY KEY 제약 조건이 우선시되어 클러스터형 인덱스가 생성됩니다.
PRIMARY KEY는 유일성과 물리적인 데이터 저장 순서를 보장해야 하기 때문에 클러스터형 인덱스를 사용하는 것이 일반적입니다.

5. PRIMARY KEY로 지정한 열을 기준으로 데이터가 오름차순 정렬
PRIMARY KEY로 지정된 열은 테이블의 기본 정렬 기준이 됩니다.
클러스터형 인덱스는 PRIMARY KEY로 지정된 열을 기준으로 데이터를 오름차순(ASC)으로 정렬하여 저장합니다.
이렇게 하면 해당 열을 기준으로 데이터를 검색하거나 정렬할 때 빠른 성능을 제공할 수 있습니다.

